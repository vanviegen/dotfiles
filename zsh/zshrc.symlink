# Start tmux instead if we're not already in tmux, we're not in vscode and it's an interactive session
if [[ -z "$TMUX" && -z "$SUING" && "$TERM_PROGRAM" != "vscode" && $- == *i* ]]; then
    if command -v tmux > /dev/null; then
        exec tmux new-session -A -s $USER-main
    else
        echo "Failed to start tmux"
    fi
fi

if [[ -z "$SUING" ]] ; then
    export "DOT=$HOME/.dotfiles"
    export PATH="$DOT/bin:$DOT/xbin:$HOME/.local/bin:$HOME/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/bin:$PATH"
else
    export "DOT=$SUING"
    if [ -f $SUING/../.sudo-path.tmp ] ; then
      export PATH=$(cat $SUING/../.sudo-path.tmp)
    fi
fi
if [[ $EUID -eq 0 ]]; then # user is root
  export PATH="$PATH:/sbin:/usr/sbin"
fi

# Configuration for various tools
export COLORTERM=truecolor
export FZF_DEFAULT_COMMAND='rg --files'
export LESS='-iMSx4 -FX -R'
export PAGER=less
export EDITOR=hx
alias open=xdg-open
alias cs=rg

# History config
SAVEHIST=10000
HISTSIZE=10000
HISTFILE=~/.zsh_history
setopt SHARE_HISTORY
setopt APPEND_HISTORY
setopt HIST_FIND_NO_DUPS
setopt HIST_REDUCE_BLANKS
setopt EXTENDED_HISTORY

# Offer to correct mistyped commands
setopt CORRECT

# This script was automatically generated by the broot program
# More information can be found in https://github.com/Canop/broot
# This function starts broot and executes the command
# it produces, if any.
# It's needed because some shell commands, like `cd`,
# have no useful effect if executed in a subshell.
function br {
    local cmd cmd_file code
    cmd_file=$(mktemp)
    if broot --outcmd "$cmd_file" "$@"; then
        cmd=$(<"$cmd_file")
        command rm -f "$cmd_file"
        eval "$cmd"
    else
        code=$?
        command rm -f "$cmd_file"
        return "$code"
    fi
}

# Load and initialise completion system
autoload -Uz compinit
# When sudoing, we don't want this file to be created in the original user's home directory
compinit -i -d ~/.cache/zcompdump

# Load our package manager, zap
export XDG_DATA_HOME="$DOT/../.local/share"
source "$XDG_DATA_HOME/zap/zap/zap.zsh"
export XDG_DATA_HOME=

# Have agnoster hide our user name when it's "frank"
export DEFAULT_USER=frank
# Use the agnoster prompt
setopt promptsubst
plug agnoster/agnoster-zsh-theme

# Use esc+esc to prepend 'S ' for sudo
toggle_prefix() {
    if [[ "$BUFFER" == S\ * ]]; then
        CURSOR=$((CURSOR > 2 ? CURSOR - 2 : 0))
        BUFFER="${BUFFER:2}"
    else
        BUFFER="S $BUFFER"
        CURSOR+=2
    fi
}
zle -N toggle_prefix
bindkey -M viins '\e\e' toggle_prefix
bindkey -M emacs '\e\e' toggle_prefix

# Fix keys like home and ctrl-left, and add some nice shortcuts like ctrl-x ctrl-e to edit command in editor
plug embeddedpenguin/sanekeybinds

# Show autocomplate suggestions without prompting
#plug marlonrichert/zsh-autocomplete

# Make Tab go straight to the menu and cycle there
#bindkey '\t' menu-select "$terminfo[kcbt]" menu-select
#bindkey -M menuselect '\t' menu-complete "$terminfo[kcbt]" reverse-menu-complete

# Syntax highlighting
plug zdharma-continuum/fast-syntax-highlighting

# Set the tmux title to current program/dir, based on https://github.com/pawel-slowik/zsh-term-title
function term_set_title() {
    local max_length=20
    local title="${1//[^[:print:]]/}"

    if [[ ${#title} -gt $max_length ]]; then
        title="${title:0:$max_length}.."
    fi

    printf '\033k%s\033\\' "$title"
}
function term_title_precmd() {
    local dir='%~'
    term_set_title ${(%)dir}
}
function term_title_preexec() {
    local job_text job_key
    job_text="$1"
    # Since ~4.3.5, patch:
    # "users/11818: allow non-numeric keys for job status parameters"
    # it is possible to use the `fg ...` or `%...` description as a key
    # in $jobtexts.
    case $1 in
    		%*) job_key=$1 ;;
    		fg) job_key=%+ ;;
    		fg*) job_key=${(Q)${(z)1}[2,-1]} ;;
    		*) job_key='' ;;
    esac
    if [[ -n $job_key ]] then
        job_text=${jobtexts[$job_key]} 2> /dev/null
        if [[ -z $job_text ]] then
        		# job lookup failed - use the original command
        		job_text="$1"
        fi
    fi
    term_set_title $job_text
}
autoload -Uz add-zsh-hook
add-zsh-hook precmd term_title_precmd
add-zsh-hook preexec term_title_preexec

# Use eza instead of ls and the like
eza_params="--git --icons --classify --time-style=long-iso --group --color-scale all"
alias l="eza --group-directories-first $eza_params"
alias ll="eza --all --header --long --group-directories-first $eza_params"
alias lt="eza --all --header --long --sort=modified $eza_params"
alias la="eza -lbhHigUmuSaB@"
alias ltree="eza --tree --group-directories-first $eza_params"

# Completion for S (sudo) commands
_S() {
  if [[ $words[2] == :* ]]; then
    if (( CURRENT == 2 )); then
        local -a users
        users=($(cut -d: -f1 /etc/passwd))
        compset -P ':'
        _describe 'user' users
    else
        _arguments \
            '1:first-arg' \
            '*::rest:->rest'
        _command
    fi
  else
    _command
  fi
}
compdef _S S

# Use fzf for history search
FZF_DEFAULT_OPTS="--color=fg:1,fg+:2 --bind=tab:accept" 
source <(fzf-tmux --zsh)

# Tab completion
# disable sort when completing `git checkout`
zstyle ':completion:*:git-checkout:*' sort false
# set descriptions format to enable group support
# NOTE: don't use escape sequences (like '%F{red}%d%f') here, fzf-tab will ignore them
zstyle ':completion:*:descriptions' format '[%d]'
# set list-colors to enable filename colorizing
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# force zsh not to show completion menu, which allows fzf-tab to capture the unambiguous prefix
zstyle ':completion:*' menu no
# preview directory's content with eza when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always $realpath'
# To make fzf-tab follow FZF_DEFAULT_OPTS.
zstyle ':fzf-tab:*' use-fzf-default-opts yes
# switch group using `<` and `>`
zstyle ':fzf-tab:*' switch-group '<' '>'
# use tmux popups for previews
zstyle ':fzf-tab:*' fzf-command fzf-tmux
plug Aloxaf/fzf-tab


# Create aliases for all flatpak commands that are not in the PATH as well
while IFS=$'\t' read -r app_id ; do
    local alias_name=$(echo "$app_id" | awk -F. '{print tolower($NF)}')
    if ! command -v "$alias_name" &>/dev/null; then
        alias "$alias_name"="flatpak run $app_id"
    fi
done < <(flatpak list --app --columns=application)

# Fix completion for arguments to flatpak applications
_flatpak_run_with_file_completion() {
  local curcontext="$curcontext" state line
  typeset -A opt_args
  _arguments -C \
    '1: :_flatpak_applications' \
    '*: :_files'
}
compdef _flatpak_run_with_file_completion flatpak

if [ -e ~/Documents/keys/openai.key ] ; then
    export OPENAI_API_KEY=`cat ~/Documents/keys/openai.key`
fi

if [ -e ~/Documents/keys/anthropic.key ] ; then
    export ANTHROPIC_API_KEY=`cat ~/Documents/keys/anthropic.key`
fi
